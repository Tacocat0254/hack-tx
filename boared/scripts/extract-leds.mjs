#!/usr/bin/env node
import fs from 'node:fs'
import path from 'node:path'
import Database from 'better-sqlite3'

const dbPath = process.argv[2] ?? path.resolve('data/kilterboard.db')
const outputPath = process.argv[3] ?? path.resolve('src/modules/kilterboardPositions.ts')

const header = `/**
 * This file is auto-generated by scripts/extract-leds.mjs.
 * Source: SQLite table \'leds\' (columns: hole_id, position).
 * Run "npm run extract:leds" after updating the database dump.
 */\n`

function formatPlacements(rows) {
  const lines = rows
    .map(({ boardX, boardY, holeId, position }) =>
      `${boardX}\t${boardY}\t${holeId}\t${position}`,
    )
    .join('\n')

  return lines
}

function createModule(rows) {
  const dataLines = rows
    .map(({ boardX, boardY, holeId, position }) =>
      `  { boardX: ${boardX}, boardY: ${boardY}, holdId: ${holeId}, positionCode: ${position} },`,
    )
    .join('\n')

  return `${header}
export interface KilterBoardPlacement {\n  boardX: number\n  boardY: number\n  holdId: number\n  positionCode: number\n}\n\nexport const KILTER_BOARD_PLACEMENTS: KilterBoardPlacement[] = [\n${dataLines}\n]\n\nexport const HOLD_ID_TO_POSITION: Record<number, number> = Object.fromEntries(\n  KILTER_BOARD_PLACEMENTS.map(({ holdId, positionCode }) => [holdId, positionCode]),\n)\n\nexport function getPositionCodeFromHoldId(holdId: number | string): number | undefined {\n  const key = typeof holdId === 'string' ? Number.parseInt(holdId, 10) : holdId\n  if (Number.isNaN(key)) return undefined\n  return HOLD_ID_TO_POSITION[key]\n}\n`
}

function main() {
  if (!fs.existsSync(dbPath)) {
    console.error(`SQLite database not found at ${dbPath}`)
    process.exit(1)
  }

  const db = new Database(dbPath, { readonly: true })

  const rows = db
    .prepare(
      `SELECT l.x as boardX, l.y as boardY, l.hole_id as holeId, l.position\n       FROM leds l\n       ORDER BY l.position`,
    )
    .all()

  db.close()

  if (rows.length === 0) {
    console.error('No rows returned from leds table. Check the database contents.')
    process.exit(1)
  }

  const moduleSource = createModule(rows)
  fs.writeFileSync(outputPath, moduleSource + '\n', 'utf8')

  console.log(`Generated ${outputPath}`)
  console.log(`Mapped ${rows.length} holds from ${dbPath}`)
}

main()
